<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tank Battle - Telegram Game</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            overflow: hidden;
            touch-action: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #game {
            display: block;
            margin: 0 auto;
        }
        .controls {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
        }
        .left-controls, .right-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .control-btn {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.3);
            border: 2px solid #fff;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
        }
        .movement-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
        }
        .movement-btn {
            width: 45px;
            height: 45px;
        }
        .btn-up { grid-column: 2; grid-row: 1; }
        .btn-left { grid-column: 1; grid-row: 2; }
        .btn-down { grid-column: 2; grid-row: 3; }
        .btn-right { grid-column: 3; grid-row: 2; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game"></div>
        <div class="controls">
            <div class="left-controls">
                <div class="movement-controls">
                    <div class="control-btn movement-btn btn-up" id="btn-up">‚¨ÜÔ∏è</div>
                    <div class="control-btn movement-btn btn-left" id="btn-left">‚¨ÖÔ∏è</div>
                    <div class="control-btn movement-btn btn-down" id="btn-down">‚¨áÔ∏è</div>
                    <div class="control-btn movement-btn btn-right" id="btn-right">‚û°Ô∏è</div>
                </div>
            </div>
            <div class="right-controls">
                <div class="control-btn" id="btn-shoot">üî¥</div>
            </div>
        </div>
    </div>

    <script>
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram Web App
        const tg = window.Telegram.WebApp;
        tg.expand();
        tg.enableClosingConfirmation();

        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
            }

            preload() {
                this.createTankTexture('tank', 0x00ff00);
                this.createTankTexture('enemy', 0xff0000);
                this.createWallTexture('wall', 0x666666);
                this.createWallTexture('steel', 0x8888ff);
                this.createBulletTexture('bullet', 0xffff00);
            }

            createTankTexture(key, color) {
                const graphics = this.add.graphics();
                graphics.fillStyle(color);
                graphics.fillRoundedRect(4, 4, 24, 24, 5);
                graphics.fillStyle(0x333333);
                graphics.fillRect(14, 0, 4, 12);
                graphics.fillStyle(0x222222);
                graphics.fillRect(2, 8, 28, 4);
                graphics.fillRect(2, 20, 28, 4);
                graphics.generateTexture(key, 32, 32);
                graphics.destroy();
            }

            createWallTexture(key, color) {
                const graphics = this.add.graphics();
                graphics.fillStyle(color);
                graphics.fillRect(0, 0, 32, 32);
                graphics.fillStyle(0x000000, 0.3);
                for (let x = 0; x < 32; x += 8) {
                    for (let y = 0; y < 32; y += 8) {
                        if ((x + y) % 16 === 0) {
                            graphics.fillRect(x, y, 6, 6);
                        }
                    }
                }
                graphics.generateTexture(key, 32, 32);
                graphics.destroy();
            }

            createBulletTexture(key, color) {
                const graphics = this.add.graphics();
                graphics.fillStyle(color);
                graphics.fillCircle(4, 4, 3);
                graphics.fillStyle(0xffffff, 0.8);
                graphics.fillCircle(2, 2, 1);
                graphics.generateTexture(key, 8, 8);
                graphics.destroy();
            }

            create() {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—é –¥–æ—Å—Ç—É–ø–Ω—É—é –æ–±–ª–∞—Å—Ç—å
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight - 120; // –£—á–∏—Ç—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫–∏
                
                this.score = 0;
                this.totalEnemiesKilled = 0;
                this.maxEnemies = 6;
                this.lastFired = 0;
                
                this.cameras.main.setBackgroundColor(0x0a0a0a);
                
                this.walls = this.physics.add.staticGroup();
                this.bullets = this.physics.add.group();
                this.enemies = this.physics.add.group();
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–∞–∑–º–µ—Ä—ã –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –¥—Ä—É–≥–∏—Ö –º–µ—Ç–æ–¥–∞—Ö
                this.gameWidth = screenWidth;
                this.gameHeight = screenHeight;
                
                this.createField();
                this.createPlayer();
                this.createEnemies();
                this.setupMobileControls();
                this.setupCollisions();
                this.createUI();
                this.setupEnemySpawning();
            }

            createField() {
                const cellSize = 32;
                const cols = Math.floor(this.gameWidth / cellSize);
                const rows = Math.floor(this.gameHeight / cellSize);
                
                console.log(`Field size: ${cols}x${rows} cells`);
                
                // –ì—Ä–∞–Ω–∏—Ü—ã –ø–æ–ª—è - —Ç–æ—á–Ω–æ –ø–æ –∫—Ä–∞—è–º —ç–∫—Ä–∞–Ω–∞
                for (let x = 0; x < cols; x++) {
                    this.walls.create(x * cellSize + cellSize/2, cellSize/2, 'wall');
                    this.walls.create(x * cellSize + cellSize/2, this.gameHeight - cellSize/2, 'wall');
                }
                for (let y = 0; y < rows; y++) {
                    this.walls.create(cellSize/2, y * cellSize + cellSize/2, 'wall');
                    this.walls.create(this.gameWidth - cellSize/2, y * cellSize + cellSize/2, 'wall');
                }
                
                // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
                const obstacles = [
                    [3, 3, 'wall'], [4, 3, 'steel'], [5, 3, 'wall'],
                    [cols-6, 3, 'steel'], [cols-5, 3, 'wall'], [cols-4, 3, 'steel'],
                    [3, rows-4, 'wall'], [3, rows-5, 'steel'], [3, rows-6, 'wall'],
                    [cols-4, rows-4, 'steel'], [cols-4, rows-5, 'wall'], [cols-4, rows-6, 'steel'],
                    [Math.floor(cols/2), Math.floor(rows/2), 'steel'],
                    [Math.floor(cols/2)-1, Math.floor(rows/2), 'wall'],
                    [Math.floor(cols/2)+1, Math.floor(rows/2), 'wall'],
                    [Math.floor(cols/3), Math.floor(rows/3), 'wall'],
                    [Math.floor(cols*2/3), Math.floor(rows*2/3), 'wall']
                ];
                
                obstacles.forEach(coord => {
                    if (coord[0] < cols-1 && coord[1] < rows-1) {
                        this.walls.create(coord[0] * cellSize + cellSize/2, coord[1] * cellSize + cellSize/2, coord[2]);
                    }
                });
            }

            createPlayer() {
                // –°—Ç–∞—Ä—Ç–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –≤–Ω–∏–∑—É –ø–æ —Ü–µ–Ω—Ç—Ä—É
                this.player = this.physics.add.sprite(
                    this.gameWidth / 2, 
                    this.gameHeight - 100, 
                    'tank'
                );
                this.player.setCollideWorldBounds(true);
                this.player.setBounce(0.3); // –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç—Å–∫–æ–∫ –æ—Ç —Å—Ç–µ–Ω
                this.player.health = 3;
                this.player.direction = 'up';
                this.player.type = 'player';
                this.player.setTint(0x00ff00);
                
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –º–∏—Ä–∞
                this.physics.world.setBounds(0, 0, this.gameWidth, this.gameHeight);
            }

            createEnemies() {
                const spawnPoints = [
                    {x: this.gameWidth * 0.3, y: 80}, 
                    {x: this.gameWidth * 0.7, y: 80},
                    {x: this.gameWidth * 0.2, y: 120},
                    {x: this.gameWidth * 0.8, y: 120}
                ];
                
                for (let i = 0; i < 3; i++) {
                    this.createEnemy(spawnPoints[i].x, spawnPoints[i].y);
                }
            }

            createEnemy(x, y) {
                const enemy = this.physics.add.sprite(x, y, 'enemy');
                enemy.setCollideWorldBounds(true);
                enemy.setBounce(0.3); // –û—Ç—Å–∫–æ–∫ –æ—Ç —Å—Ç–µ–Ω
                enemy.direction = 'down';
                enemy.type = 'enemy';
                enemy.lastDirectionChange = 0;
                enemy.lastShotTime = 0;
                
                const directions = [
                    { vx: 0, vy: 60 }, { vx: 0, vy: -60 },
                    { vx: 60, vy: 0 }, { vx: -60, vy: 0 }
                ];
                const dir = Phaser.Utils.Array.GetRandom(directions);
                enemy.setVelocity(dir.vx, dir.vy);
                
                this.enemies.add(enemy);
                return enemy;
            }

            setupMobileControls() {
                this.btnLeft = document.getElementById('btn-left');
                this.btnRight = document.getElementById('btn-right');
                this.btnUp = document.getElementById('btn-up');
                this.btnDown = document.getElementById('btn-down');
                this.btnShoot = document.getElementById('btn-shoot');
                
                this.setupButton(this.btnLeft, 'left');
                this.setupButton(this.btnRight, 'right');
                this.setupButton(this.btnUp, 'up');
                this.setupButton(this.btnDown, 'down');
                this.setupButton(this.btnShoot, 'shoot');
            }

            setupButton(button, action) {
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this[`${action}Pressed`] = true;
                });
                
                button.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this[`${action}Pressed`] = false;
                });
                
                button.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this[`${action}Pressed`] = true;
                });
                
                button.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this[`${action}Pressed`] = false;
                });
            }

            setupCollisions() {
                // –ö–æ–ª–ª–∏–∑–∏–∏ —Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –º–∏—Ä–∞
                this.physics.add.collider(this.player, this.walls);
                this.physics.add.collider(this.enemies, this.walls);
                this.physics.add.collider(this.player, this.enemies);
                this.physics.add.collider(this.enemies, this.enemies);
                
                // –ü—É–ª–∏ —É–Ω–∏—á—Ç–æ–∂–∞—é—Ç—Å—è –æ —Å—Ç–µ–Ω—ã
                this.physics.add.collider(this.bullets, this.walls, (bullet, wall) => {
                    this.createExplosion(bullet.x, bullet.y, 0x888888);
                    bullet.destroy();
                });

                // –ü—É–ª–∏ —Å—Ç–∞–ª–∫–∏–≤–∞—é—Ç—Å—è –¥—Ä—É–≥ —Å –¥—Ä—É–≥–æ–º
                this.physics.add.collider(this.bullets, this.bullets, (bullet1, bullet2) => {
                    this.createExplosion(bullet1.x, bullet1.y, 0xffff00);
                    bullet1.destroy();
                    bullet2.destroy();
                });
            }

            createExplosion(x, y, color) {
                const graphics = this.add.graphics();
                graphics.fillStyle(color);
                graphics.fillCircle(x, y, 8);
                this.time.delayedCall(200, () => graphics.destroy());
            }

            update(time) {
                if (this.player.health <= 0) return;
                
                this.handleMobileInput(time);
                this.updateEnemiesAI(time);
                this.checkBulletHits();
                this.checkTankCollisions();
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ–±—ã —Ç–∞–Ω–∫–∏ –Ω–µ –≤—ã—Ö–æ–¥–∏–ª–∏ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã
                this.ensureInBounds(this.player);
                this.enemies.getChildren().forEach(enemy => this.ensureInBounds(enemy));
            }

            ensureInBounds(tank) {
                const padding = 16;
                tank.x = Phaser.Math.Clamp(tank.x, padding, this.gameWidth - padding);
                tank.y = Phaser.Math.Clamp(tank.y, padding, this.gameHeight - padding);
            }

            handleMobileInput(time) {
                this.player.setVelocity(0);
                
                if (this.leftPressed) {
                    this.player.setVelocityX(-150);
                    this.player.rotation = -1.57;
                    this.player.direction = 'left';
                } else if (this.rightPressed) {
                    this.player.setVelocityX(150);
                    this.player.rotation = 1.57;
                    this.player.direction = 'right';
                }
                
                if (this.upPressed) {
                    this.player.setVelocityY(-150);
                    this.player.rotation = 0;
                    this.player.direction = 'up';
                } else if (this.downPressed) {
                    this.player.setVelocityY(150);
                    this.player.rotation = 3.14;
                    this.player.direction = 'down';
                }
                
                if (this.shootPressed && time > this.lastFired) {
                    this.createBullet(this.player, 0x00ff00);
                    this.lastFired = time + 500;
                }
            }

            setupEnemySpawning() {
                this.enemySpawnTimer = this.time.addEvent({
                    delay: 5000,
                    callback: this.spawnNewEnemy,
                    callbackScope: this,
                    loop: true
                });
            }

            spawnNewEnemy() {
                if (this.enemies.getLength() >= this.maxEnemies) return;
                
                const spawnPoints = [
                    {x: 50, y: 50}, 
                    {x: this.gameWidth - 50, y: 50},
                    {x: this.gameWidth / 2, y: 50},
                    {x: 80, y: 80},
                    {x: this.gameWidth - 80, y: 80}
                ];
                
                const spawnPoint = Phaser.Utils.Array.GetRandom(spawnPoints);
                this.createEnemy(spawnPoint.x, spawnPoint.y);
            }

            createUI() {
                const style = {
                    fontSize: '18px',
                    fill: '#ffffff',
                    fontStyle: 'bold',
                    stroke: '#000000',
                    strokeThickness: 3
                };
                
                this.scoreText = this.add.text(100, 20, 'üèÜ: 0', { 
                    ...style,
                    fill: '#ffff00'
                });
                
                this.healthText = this.add.text(20, 20, '‚ù§Ô∏è: 3', { 
                    ...style,
                    fill: '#ff4444'
                });
            }

            updateEnemiesAI(time) {
                const enemies = this.enemies.getChildren();
                
                for (let enemy of enemies) {
                    if (!enemy.active) continue;
                    
                    // –ú–µ–Ω—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º
                    if (time > enemy.lastDirectionChange + Phaser.Math.Between(2000, 5000)) {
                        const directions = [
                            { vx: 0, vy: -80, rot: 0, dir: 'up' },
                            { vx: 0, vy: 80, rot: 3.14, dir: 'down' },
                            { vx: -80, vy: 0, rot: -1.57, dir: 'left' },
                            { vx: 80, vy: 0, rot: 1.57, dir: 'right' }
                        ];
                        
                        const newDir = Phaser.Utils.Array.GetRandom(directions);
                        enemy.setVelocity(newDir.vx, newDir.vy);
                        enemy.rotation = newDir.rot;
                        enemy.direction = newDir.dir;
                        enemy.lastDirectionChange = time;
                    }
                    
                    // –°—Ç—Ä–µ–ª—å–±–∞
                    if (time > enemy.lastShotTime + Phaser.Math.Between(2000, 4000)) {
                        this.createBullet(enemy, 0xff0000);
                        enemy.lastShotTime = time;
                    }
                }
            }

            checkBulletHits() {
                const bullets = this.bullets.getChildren();
                const enemies = this.enemies.getChildren();
                
                for (let bullet of bullets) {
                    if (!bullet.active) continue;
                    
                    // –ü—É–ª–∏ –∏–≥—Ä–æ–∫–∞ –ø–æ–ø–∞–¥–∞—é—Ç –≤–æ –≤—Ä–∞–≥–æ–≤
                    if (bullet.tintTopLeft === 0x00ff00) {
                        for (let enemy of enemies) {
                            if (!enemy.active) continue;
                            
                            const distance = Phaser.Math.Distance.Between(
                                bullet.x, bullet.y, enemy.x, enemy.y
                            );
                            
                            if (distance < 20) {
                                this.createExplosion(enemy.x, enemy.y, 0xff0000);
                                bullet.destroy();
                                this.enemyDestroyed(enemy);
                                break;
                            }
                        }
                    }
                    
                    // –ü—É–ª–∏ –≤—Ä–∞–≥–æ–≤ –ø–æ–ø–∞–¥–∞—é—Ç –≤ –∏–≥—Ä–æ–∫–∞
                    if (bullet.tintTopLeft === 0xff0000) {
                        const distance = Phaser.Math.Distance.Between(
                            bullet.x, bullet.y, this.player.x, this.player.y
                        );
                        
                        if (distance < 20) {
                            this.createExplosion(this.player.x, this.player.y, 0x00ff00);
                            bullet.destroy();
                            this.playerHit();
                        }
                    }
                }
            }

            checkTankCollisions() {
                const enemies = this.enemies.getChildren();
                
                for (let enemy of enemies) {
                    if (!enemy.active) continue;
                    
                    const distance = Phaser.Math.Distance.Between(
                        this.player.x, this.player.y, enemy.x, enemy.y
                    );
                    
                    // –û—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ –ø—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏ —Ç–∞–Ω–∫–æ–≤
                    if (distance < 30) {
                        const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, enemy.x, enemy.y);
                        this.player.x += Math.cos(angle) * 3;
                        this.player.y += Math.sin(angle) * 3;
                        enemy.x -= Math.cos(angle) * 3;
                        enemy.y -= Math.sin(angle) * 3;
                    }
                }
            }

            enemyDestroyed(enemy) {
                const points = 100;
                this.score += points;
                this.totalEnemiesKilled++;
                
                this.scoreText.setText('üèÜ: ' + this.score);
                
                enemy.destroy();
            }

            playerHit() {
                this.player.health--;
                this.healthText.setText('‚ù§Ô∏è: ' + this.player.health);
                
                // –ú–∏–≥–∞–Ω–∏–µ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —É—Ä–æ–Ω–∞
                this.tweens.add({
                    targets: this.player,
                    alpha: 0.5,
                    duration: 100,
                    yoyo: true,
                    repeat: 2
                });
                
                if (this.player.health <= 0) {
                    this.playerDestroyed();
                }
            }

            playerDestroyed() {
                this.createExplosion(this.player.x, this.player.y, 0xff0000);
                this.player.setTint(0x666666);
                this.player.setVelocity(0, 0);
                
                this.add.text(this.gameWidth / 2, this.gameHeight / 2, 
                    '–ö–æ–Ω–µ—Ü –∏–≥—Ä—ã!\n–°—á–µ—Ç: ' + this.score, { 
                    fontSize: '28px',
                    fill: '#ff4444',
                    fontStyle: 'bold',
                    stroke: '#000000',
                    strokeThickness: 4,
                    align: 'center'
                }).setOrigin(0.5);
                
                this.physics.pause();
            }

            createBullet(shooter, color) {
                const bullet = this.bullets.create(shooter.x, shooter.y, 'bullet');
                bullet.setTint(color);
                
                const speed = 300;
                let velocityX = 0;
                let velocityY = 0;
                
                switch (shooter.direction) {
                    case 'up': velocityY = -speed; break;
                    case 'down': velocityY = speed; break;
                    case 'left': velocityX = -speed; break;
                    case 'right': velocityX = speed; break;
                }
                
                bullet.setVelocity(velocityX, velocityY);
                bullet.setCollideWorldBounds(true);
                
                // –ê–≤—Ç–æ—É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–µ –ø—É–ª—å —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã
                this.time.delayedCall(2000, () => {
                    if (bullet.active) bullet.destroy();
                });
            }
        }

        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–≥—Ä—ã
        const config = {
            type: Phaser.AUTO,
            width: window.innerWidth,
            height: window.innerHeight - 120,
            parent: 'game',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: GameScene
        };

        const game = new Phaser.Game(config);

        // –ê–¥–∞–ø—Ç–∞—Ü–∏—è –∫ –∏–∑–º–µ–Ω–µ–Ω–∏—é —Ä–∞–∑–º–µ—Ä–∞ —ç–∫—Ä–∞–Ω–∞
        window.addEventListener('resize', () => {
            game.scale.resize(window.innerWidth, window.innerHeight - 120);
            // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º —Å—Ü–µ–Ω—É –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞
            game.scene.restart();
        });
    </script>
</body>
</html>
